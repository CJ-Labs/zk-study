# 1. Plonk 的基本架构
Plonk = 电路约束 + 多项式承诺 <br/>
**电路约束**:
1. [门约束](./circuit/5.门约束.md) - 运算单元的计算约束
2. [线约束](./circuit/6.线约束.md) - 导线连接的相等约束
# 2. 重要组件
## 2.1 [KZG多项式承诺](./promise/3.kzg多项式承诺.md)
- `KZG Setup`: 生成结构化参考串(SRS)
- `Commit`: 生成多项式承诺
- `Open`: 生成评估证明
- `Verify`: 验证评估证明
## 2.2 门约束组件
- 加法门、乘法门、常量门
## 2.3 线约束组件
- 置换证明、复制约束
## 2.4 证明系统
- Round 1: 承诺门信号多项式
- Round 2: 承诺线约束多项式
- Round 3: 计算约束满足证明
- Round 4: 计算多项式评估点
- Round 5: 生成最终证明
## 2.5 验证系统
- 检查承诺有效性
- 验证门约束满足
- 验证线约束满足
- 验证评估正确性
2.6 基础工具组件
- 有限域运算
- 多项式运算
- FFT/iFFT 变换
- 椭圆曲线运算
# 3. [门约束](./circuit/5.门约束.md)
## 3.1.  通用门方程
`QL⋅a + QR⋅b + QO⋅c + QM⋅(a⋅b) + QC = 0`
- `a,b`是门的输入/ `c` 是输出信号
- `QL,QR,QO,QM,QC` 是系数
- 通过调整系数可以表达不同类型的门
## 3.2. 门类型示例
```sh
// 加法门
`QL = 1, QR = 1, QO = -1, QM = 0, QC = 0  `
// 表达:` a + b - c = 0`

// 乘法门  
QL = 0, QR = 0, QO = -1, QM = 1, QC = 0
// 表达: a⋅b - c = 0

// 常量门
QL = 1, QR = 0, QO = 0, QM = 0, QC = -k 
// 表达: a = k
```
# 4. [线约束](./circuit/6.线约束.md) 
## 4.1. 基本原理
使用置换累加器(permutation accumulator)验证信号相等:  <br>
 
如果 `a[i] = b[j]`, 则: <br>
`P(x) = P'(x)`  <br>

其中 P(x) 是原始累加器 <br>
P'(x) 是置换后的累加器 <br>
## 4.. 实现方式
1. 为每个信号分配唯一标识
`id[signal] = index`
2. 构造累加器
`P(x) = Σ (u⋅id[i] + v⋅value[i])⋅x^i`
2. 验证相等信号的累加器值相同
`P(x) = P'(x) ⟹ signals are equal`
4. 证明生成流程
- Round 1: 承诺门信号多项式
- Round 2: 承诺线约束多项式
- Round 3: 计算约束满足证明
- Round 4: 计算多项式评估点
- Round 5: 生成最终证明

# 5. 与 Groth16 对比
Groth16: <br>
优点:
- 证明小且验证快
- 适合固定电路 <br>

缺点:
- 需要每个电路单独的可信设置
- 电路修改成本高

Plonk: <br>
优点:
- 通用可信设置
- 支持电路灵活修改 <br>

缺点:
- 证明较大
- 验证较慢