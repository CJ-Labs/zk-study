Groth16 和 PLONK 是两种流行的零知识证明系统，它们都可以实现非交互式零知识证明（NIZK）。非交互式的特性主要通过 `Fiat-Shamir` 启发式来实现。以下是这两种系统如何做到非交互式的详细解释：
# Fiat-Shamir 启发式
`Fiat-Shamir` 启发式是一种将交互式证明协议转换为非交互式的通用方法。 <br/>
其基本思想是用哈希函数代替交互式协议中的随机挑战。 <br/>
- 用确定性的哈希函数替代验证者的随机挑战
- 使证明者可以自己生成挑战，无需与验证者交互
<br/>

具体步骤如下：
1. **交互式协议**: 在交互式零知识证明中，验证者会向证明者发送随机挑战，证明者根据挑战生成响应。
2. **哈希函数替代**: 在非交互式设置中，证明者使用哈希函数生成“挑战”。证明者将待证明的陈述和初始承诺值作为输入，计算哈希值，并将其作为挑战。
3. **生成证明**: 证明者根据生成的挑战计算响应，并将证明（包括承诺、挑战和响应）发送给验证者。
4. **验证过程**: 验证者使用相同的哈希函数和输入重新计算挑战，并验证证明的有效性。
# Groth16 的非交互式实现
- 结构: Groth16 是一种非常高效的 zk-SNARK（零知识简洁非交互式知识论证），其证明由固定数量的群元素组成。
- 非交互式特性: Groth16 本身就是设计为非交互式的，通过`可信设置（trusted setup）`生成公共参数，允许证明者生成非交互式证明。
- 应用: Groth16 的小证明和快速验证使其非常适合区块链应用。
- Groth16 不使用 `Fiat-Shamir` 变换
## PLONK 的非交互式实现
- 结构: PLONK 是一种通用的 zk-SNARK，支持任意电路的证明。
- 非交互式特性: PLONK 使用**通用的可信设置**，允许在不同电路之间`重用公共参数`。通过 Fiat-Shamir 启发式，PLONK 可以生成非交互式证明。
- 应用: PLONK 的灵活性和通用性使其适合于需要频繁更改电路的应用。
- PLONK 使用 `Fiat-Shamir` 变换
# 总结
`Fiat-Shamir`启发式: 通过使用哈希函数代替交互式协议中的随机挑战，实现非交互式零知识证明。 <br/>
Groth16 和 PLONK: 通过设计和技术手段，支持非交互式证明，适合于区块链和其他需要高效证明的应用场景。  <br/>

## issue
Fiat-Shamir 变换 —— 从 Public-Coin 到 NIZK   <br/>
如何基于 CRS 来构造 NIZK 