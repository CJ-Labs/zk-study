# 1. Schnorr 签名概述
Schnorr 签名基于`有限域椭圆曲线`，与 `ECDSA` 相比具有以下优势：
- 计算速度更快
- 可以实现多签聚合
- 验证过程更简单

# 2. 基本参数
- `Ep(a,b)`: 椭圆曲线
- `G`: 基点
- `n`: 基点 `G` 的阶
- `m`: 要签名的消息
# 3. 密钥生成
1. 私钥生成：
- 从 `{1,⋯,n−1}` 随机选择 `kA`
2. 公钥计算：
- `HA = kA·G`

# 4.签名过程
1. 选择随机数：
- 从 `{1,⋯,n−1}` 中选择随机数 k

2. 计算承诺：
- `R = k·G`
- 获取 `R` 的 `x` 坐标 `Rx`

3. 计算挑战：
- `e = Hash(Rx || HA || m) mod n`

4. 计算响应：
- `s = k + e·kA mod n`

5. 最终签名：
- 输出 `(Rx, s)`

# 5. 验证过程
1. 计算挑战：
- `e = Hash(Rx || HA || m)`

2. 验证等式：
- 检查 `s·G ?= Rx + e·HA`

# 6. 与 ECDSA 的区别
- 计算效率：
  - ECDSA 需要计算`模逆元 k⁻¹`
  - Schnorr 直接计算 `s = k + e·kA mod n`
- 验证复杂度：
  - ECDSA：需要两次标量乘法 `(u₁G 和 u₂HA)`
  - Schnorr：只需验证一个等式 `sG = R + eP`
# 7. Schnorr 聚合签名
## 1. 初始化：
- 所有参与者使用相同的曲线和基点`G`
- 每个参与者生成私钥 `km` 和公钥 `Pi`
## 2. 签名过程
1. 每个参与者：
- 选择随机数 `ki`
- 计算 `Ri = ki·G`

2. 聚合计算：
- Pagg = `∑Pi`（公钥聚合）
- Ragg = `∑Ri`（R点聚合）

3. 计算挑战：
- `e = Hash(Ragg || Pagg || m)`

4. 计算签名：
- 每个参与者计算 `si = ki + e·km mod n`
- 聚合签名 `sagg = ∑si mod n`

5. 最终签名：
   - 输出 `(Ragg, sagg)`
## 3. 验证签名
```sh
验证等式: sagg·G = Ragg + e·Pagg

左边 = sagg·G 
     = (∑si)·G 
     = ∑(ki + e·km)·G

右边 = Ragg + e·Pagg
     = (∑Ri) + e·(∑Pi)
     = (∑ki·G) + e·(∑km·G)
     = ∑(ki·G + e·km·G)
     = ∑((ki + e·km)·G)
```
## 聚合签名优势
- 减少签名数据大小
- 降低交易费用
- 提高验证效率