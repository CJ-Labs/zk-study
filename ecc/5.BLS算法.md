#　1. 前置知识
## 1.1. 双线性配对 e
  - ```e(G1, G2) → GT```
  - ```e(aP, bQ) = e(P, Q)^(ab)```
## 1.2. 群
- G1：第一个椭圆曲线群  （存放公钥）  
  - 是一条椭圆曲线上点的集合
  - 例如：y² = x³ + 3 上的点
  - 操作：点加法和标量乘法
- G2：第二个椭圆曲线群   （存放签名）
  - 是另一条（或同一条的扭曲）椭圆曲线上的点
  - 通常比G1 更复杂
  - 点加法和标量乘法
- GT：目标群。（用于验证）
  - 是有限域上的乘法群
  - 配对的结果落在这个群中
  - 操作：乘法和指数运算
<br/>

<p>比喻</p>

- G1 像是 2D 平面上的点
- G2 像是 3D 空间中的点
- GT 像是普通的数字（但有特殊的乘法规则）
## 1.3. 哈希到曲线
  - H: 消息 → G2 点
<br/>

1. 普通哈希（例如 SHA-256）
  - 输入：任意消息
  - 输出：一个数字
2. 哈希到曲线
  - 输入：任意消息
  - 输出：曲线上的一个点
  ```
  1. 例子：
    消息："Hello"
    ↓ 哈希到曲线
    点：(x, y) 在 G2 上
  ```
  ```
  2. 特点
    - 确定性：同样的输入得到同样的点
    - 均匀分布：输出点在曲线上均匀分布
    - 安全：难以预测输出点
  ```
## 1.4. 双线性配对
1. 什么是配对
  - 配对是一个特殊的数学函数 e
  - 它接收两个点（一个来自 G1，一个来自 G2）
  - 返回一个 GT 中的元素
2. 双线性是什么意思
  <p>假设:</p>
  
- P 在 G1 群中
- Q 在 G2 群中
- a 和 b 是普通数字（标量）
  <p>那么</p>

  ```e(a*P, b*Q) = e(P, Q)^(ab)```

<br/>

  <p>例子：</p>
  <p>如果 a = 3, b = 2</p>

  ```e(3P, 2Q) = e(P, Q)^6```

<p>｜类似于</p>

- 在曲线上先做乘法
- 然后做配对

<br/>
<p>简化流程</p>

  - 先做配对
  - 然后在GT 中做指数运算
# 2. BLS
## 2.1. 曲线参数
- G1：第一个椭圆曲线群  （存放公钥）
- G2：第二个椭圆曲线群   （存放签名）
- e： 双线性配对
- n： 群的阶
## 2.2. 密钥生成
- 私钥：随机数 x
- 公钥：P = x * G1
## 2.3. 签名过程
1. 哈希消息到 G2
- H = H(消息)    // H 是 G2 上的点
2. 计算签名
- σ = x * H     // 私钥乘以哈希点
## 2.4. 验证过程
1. 已知数据
  - 签名: σ (G2点)
  - 公钥: P (G1点)
  - 消息: M
  - 生成元: G1, G2
2. 验证等式推导
  - 签名 σ = x * H
  - 验证使用配对：
  - ```e(G1, σ) ?= e(P, H)```
- 因为
- ```e(G1, x * H) = e(x * G1, H) = e(P, H) ```
3. 验证步骤
  - 1. 计算消息哈希  ```H = H(消息)```
  - 2. 计算配对 检查 ```e(G1, σ) ?= e(P, H)```

# 3. 🌰 Alice 和 bob 
## 3.1. Alice 的密钥生成
- 私钥 ```x = 随机数```
- 公钥 ```P = x * G1```
## 3.2. Alice 签名消息 "Hello Bob!"
  1. 计算 ```H = H("Hello Bob!")```
  2. 计算签名 ```σ = x * H```
  3. 发送签名 σ 给 Bob
## 3.3. Bob 验证签名
  1. 计算 ```H = H("Hello Bob!")```
  2. 验证 ```e(G1, σ) ?= e(P, H)```
<br/>

# 4. 验证等式推导细节
已知条件：
- G1 是第一个群的生成元
- ```P = x * G1``` 是公钥（x 是私钥）
- H 是消息的哈希点（在 G2 上）
- ```σ = x * H``` 是签名

<br/>

验证等式：```e(G1, σ) ?= e(P, H)```
1. 左边：```e(G1, σ)```
  - 代入 ```σ = x * H```
  - ```e(G1, x * H)```
  - 根据双线性相知：```e(G1, x * H) = e(G1, H)^x```
2. 右边：```e(P, H)```
  - 代入 ```P = x * G1```
  - ```e(x * G1, H)```
  - 根据双线性相知：```e(x * G1, H)= e(G1, H)^x```
3. 所以
  - ```e(G1, x * H) = e(x * G1, H) = e(P, H)```
<br/>

# 5. BLS 特点
BLS 特点
1. 签名聚合
  - 可以将多个签名合并为一个签名
  - ```σ_total = σ1 + σ2 + ... + σn```
2. 短签名
  - 签名长度更短 （单个 G2 点）
  - 比 ECDSA 签名更短
3. 确定性
  - 不需要随机数（避免了ECDSA的随机数问题）
  - 相同消息产生相同签名

# 6.代码实现
[BLS代码](https://github.com/CJ-Labs/cryptography-go/tree/master/bls)

# 7.参考项目
[链上项目](https://github.com/dapplink-labs/l2fp-contracts)
<br/>

[链下项目](https://github.com/dapplink-labs/l2fp-aggregator)

