结合 zkmerkle-proof-of-solvency 项目看
# 1. 基本概念
## 1.1 协议目的
  - 实现高效的零知识证明
  - 生成简洁的证明大小
  - 实现快速的验证速度
## 1.2 主要组成部分
1. `CRS` (Common Reference String)
  - 包含系统参数
  - 分为证明密钥(PK)和验证密钥(VK)
2. 证明生成
  - 由证明方P生成
  - 包含三个关键点 [A]₁, [B]₂, [C]₁
3. 验证过程
  - 由验证方V执行
  - 基于双线性配对
# 2. `CRS` (Common Reference String)生成
- 可以理解为系统的"公共参数"
- 分为两部分：
  - `pk` (Proving Key): 用于生成证明
  - `vk` (Verification Key): 用于验证证明
## 2.1 数学符号解释
- `Zp*`: 有限域上的非零元素集合
- `G₁`, `G₂`: 两个不同的椭圆曲线群
- `[X]₁`: 表示 X 在 G₁ 群上的点
- `[X]₂`: 表示 X 在 G₂ 群上的点
- `e()`: 双线性配对函数

## CRS 生成
`α, β, γ, δ, x = random_from_Zp()`  # 生成随机参数

## 证明包含三个关键点
- A = [证明中的第一个元素]₁    # 在 G₁ 群上
- B = [证明中的第二个元素]₂    # 在 G₂ 群上
- C = [证明中的第三个元素]₁    # 在 G₁ 群上

# 3. 证明生成
## 3.1. 输入
- `witness`: `aᵢ` (私密输入)
- CRS中的证明密钥 `pk`

## 3.2. 随机数生成
`r, s ← Zp`  # 随机选择，用于保证零知识性

## 3.3. 计算三个关键点
```[A]₁ = (α + Σaᵢuᵢ(x) + rδ) · G₁```
```[B]₂ = (β + Σaᵢvᵢ(x) + sδ) · G₂```
```[C]₁ = (Σaᵢ(βuᵢ(x) + αvᵢ(x) + wᵢ(x))/δ + h(x)z(x)/δ + As + Br - rsδ) · G₁```

## 3.4. 输出
```proof = ([A]₁, [B]₂, [C]₁)```

<br/>

**关键点**
- A 点包含 `witness` 和随机数 `r`
- B 点包含 `witness` 和随机数 `s`
- C 点包含所有交叉项和修正项

# 4. 验证过程
## 4.1. 输入
- `proof`: `([A]₁, [B]₂, [C]₁)`
- 验证密钥 `vk`
- 公开输入
## 4.2. 验证等式
```
e([A]₁,[B]₂) = e(αG₁, βG₂) · 
                e(Σ(βuᵢ(x) + αvᵢ(x) + wᵢ(x))/γ · G₁, γG₂) · 
                e([C]₁, δG₂)
```
## 4.3. 输出
true/false  等式成立则验证通过

# 5. 代码实现
[Groth16 Demo](./groth16/groth16.go)

# Groth16 工作链
计算转换链：
- 普通计算 
→ R1CS约束 
→ QAP 
→ 配对友好多项式

证明转换链：
- 计算证明 
→ 多项式承诺 
→ 配对验证 
→ 零知识证明
